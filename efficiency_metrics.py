# -*- coding: utf-8 -*-
"""efficiency_metrics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1udsYY1sSJ-ZP4dVN_ynzJUG2jIq4urKD
"""

"""
efficiency_metrics.py

A library for data simulation and efficiency metric calculation:
    - Data simulation of DMU outputs
    - Frontier labelling (a simple FDH placeholder)
    - MRTS calculation
    - AUC (Area Under Curve) calculation using an FDH‐like approach
    - HVI (Hypervolume Indicator) calculation and a “Hull Analysis Comparison” (HAC)
    - Regression analysis on frontier DMUs

Usage Example:
    from efficiency_metrics import (
        gen_final_data_df,
        label_frontier,
        calc_mrts,
        calc_fdh_auc,
        hvi_normalization,
        calc_hvi_area,
        calc_reg,
        hull_comparison,
    )

    # Set scenario parameters
    x_pow, y_pow = 0.5, 2
    df = gen_final_data_df(n_points=100, wide=[40, 60], x_pow=x_pow, y_pow=y_pow, plotting=False)
    df = label_frontier(df, x_headers=['y1'], y_headers=['y2'])

    # Calculate metrics
    m_mean, m_mean_no_ext, m_median = calc_mrts(df, x_header='y1', y_header='y2')
    auc_total, auc_pct = calc_fdh_auc(df, x_header='y1', y_header='y2')
    hv_pct, norm_HV = hvi_normalization(df, x_headers=['y1'], y_headers=['y2'])
    hvi_results = calc_hvi_area(df, x_headers=['y1'], y_headers=['y2'])
    reg_model = calc_reg(df)
    hac_metric = hull_comparison(None, auc_pct, auc_total, auc_total)  # (dummy example)

    print("MRTS (mean, mean without extremes, median):", m_mean, m_mean_no_ext, m_median)
    print("AUC total, AUC %:", auc_total, auc_pct)
    print("HVI (HV%, normalized HV):", hv_pct, norm_HV)
    print("HVI results:", hvi_results)
    print(reg_model.summary())
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import warnings
import seaborn as sns
from pymoo.indicators.hv import HV
import statsmodels.formula.api as sm

warnings.filterwarnings("ignore")


# ==========================
# DATA SIMULATION FUNCTIONS
# ==========================

def generate_data_with_custom_outputs(n_points, n_outputs, on_frontier_percentage, r, x_pow, y_pow, plotting=False):
    """
    Generate data points for a customizable number of outputs.

    Parameters:
        n_points (int): Total number of points to generate.
        n_outputs (int): Number of output dimensions.
        on_frontier_percentage (float): Percentage of points on the frontier.
        r (float): Scale (or radius) of the production possibility set.
        x_pow (float): Exponent used in the input (inefficiency) function.
        y_pow (float): Exponent used for outputs.
        plotting (bool): If True and n_outputs==3, plot the points in 3D.

    Returns:
        np.ndarray: Generated points (shape: [n_points, n_outputs]).
    """
    n_points_frontier = int(np.ceil(n_points * on_frontier_percentage))
    n_points_inside = n_points - n_points_frontier

    # Generate interior points (inefficient DMUs)
    points_inside = []
    for _ in range(n_points_inside):
        while True:
            point = np.random.uniform(0, r, n_outputs)
            if np.sum(point ** y_pow) <= r ** x_pow:
                points_inside.append(point)
                break

    # Generate frontier points (efficient DMUs)
    points_frontier = []
    for _ in range(n_points_frontier):
        remaining = r ** x_pow
        point = np.zeros(n_outputs)
        for i in range(n_outputs - 1):
            point[i] = np.random.uniform(0, remaining)
            remaining -= point[i]
        point[-1] = remaining
        np.random.shuffle(point)
        points_frontier.append(point ** (1 / y_pow))

    all_points = np.vstack((points_inside, points_frontier))

    if plotting and n_outputs == 3:
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(all_points[:, 0], all_points[:, 1], all_points[:, 2], color='gray')
        ax.set_xlabel('Y1')
        ax.set_ylabel('Y2')
        ax.set_zlabel('Y3')
        plt.show()

    return all_points


def gen_output_with_var_cost(n_points=15, wide=[40, 60], x_pow=0.5, y_pow=2, plotting=False):
    """
    Generate outputs for several cost levels (using different radii).

    Parameters:
        n_points (int): Number of DMUs per cost level.
        wide (list): Two-element list indicating the minimum and maximum radii.
        x_pow (float): Exponent for input function.
        y_pow (float): Exponent for outputs.
        plotting (bool): Whether to plot (only works for 3 outputs).

    Returns:
        list: A list of numpy arrays for each cost level.
    """
    all_output = []
    radii = np.linspace(wide[0], wide[1], 3)
    for r in radii:
        level_output = generate_data_with_custom_outputs(
            n_points=n_points,
            n_outputs=3,
            on_frontier_percentage=0.333,
            r=r,
            x_pow=x_pow,
            y_pow=y_pow,
            plotting=plotting,
        )
        all_output.append(level_output)
    return all_output


def gen_final_data_df(n_points=15, wide=[40, 60], x_pow=0.5, y_pow=2, plotting=False):
    """
    Generate a DataFrame of simulated DMU data. Each DMU has 3 outputs and one input value.
    The 'real_x' column is computed using the production function.

    Parameters:
        n_points (int): Number of DMUs per cost level.
        wide (list): Radii range for data simulation.
        x_pow (float): Exponent for the input function.
        y_pow (float): Exponent for the outputs.
        plotting (bool): Whether to plot the 3D data (if applicable).

    Returns:
        pd.DataFrame: DataFrame with columns ['y1', 'y2', 'y3', 'x', 'real_x'].
    """
    all_output = gen_output_with_var_cost(n_points=n_points, wide=wide, x_pow=x_pow, y_pow=y_pow, plotting=plotting)
    all_output_with_input = []

    # Here we use the maximum production possibility among DMUs at each cost level
    for output in all_output:
        # Compute a common efficiency value from the frontier (using the maximum)
        eff = np.max([(pt[0] ** y_pow + pt[1] ** y_pow + pt[2] ** y_pow) ** (1 / x_pow) for pt in output])
        for pt in output:
            y1, y2, y3 = pt
            all_output_with_input.append([y1, y2, y3, eff])
    df = pd.DataFrame(all_output_with_input, columns=["y1", "y2", "y3", "x"])
    df.index = ["DMU " + str(i) for i in df.index]
    df["real_x"] = (df["y1"] ** y_pow + df["y2"] ** y_pow + df["y3"] ** y_pow) ** (1 / x_pow)
    return df


# =====================================
# FRONTIER LABELLING (A SIMPLE PLACEHOLDER)
# =====================================

def label_frontier(df, x_headers, y_headers):
    """
    Label frontier DMUs in the DataFrame.

    This simple placeholder marks as frontier (label 0) those DMUs that have the maximum y value
    (for the first y_header) for a given x. All others are labelled as non-frontier (1).

    Parameters:
        df (pd.DataFrame): DataFrame with at least the columns in x_headers and y_headers.
        x_headers (list): List with one element, e.g. ['y1'].
        y_headers (list): List with one element, e.g. ['y2'].

    Returns:
        pd.DataFrame: Copy of df with a new column 'frontier' (0 for frontier, 1 for non-frontier).
    """
    df = df.copy()
    df["frontier"] = 1
    # For simplicity, mark the DMU(s) with maximum value of y (for the first y_header) as frontier
    max_y = df[y_headers[0]].max()
    df.loc[df[y_headers[0]] == max_y, "frontier"] = 0
    return df


# =====================
# EFFICIENCY METRICS
# =====================

def calc_mrts(df, x_header, y_header):
    """
    Calculate the marginal rate of technical substitution (MRTS) for frontier DMUs.
    The function assumes that the DataFrame has been labeled with a 'frontier' column.

    Parameters:
        df (pd.DataFrame): Data with a 'frontier' column.
        x_header (str): The column name for the x-variable.
        y_header (str): The column name for the y-variable.

    Returns:
        tuple: (mean, mean_without_extremes, median) of the differences in MRTS.
    """
    df_frontier = df[df["frontier"] == 0].copy()
    df_frontier.sort_values(by=x_header, inplace=True)
    df_frontier["MRTS"] = (df_frontier[y_header].diff() / df_frontier[x_header].diff()).fillna(np.nan)
    diff_list = df_frontier["MRTS"].diff().dropna().values

    if len(diff_list) == 0:
        return np.nan, np.nan, np.nan

    m_mean = np.mean(diff_list)
    m_mean_without_extremes = np.mean(sorted(diff_list)[1:-1]) if len(diff_list) > 2 else m_mean
    m_median = np.median(diff_list)
    return m_mean, m_mean_without_extremes, m_median


def calc_fdh_auc(df, x_header, y_header):
    """
    Calculate the Area-Under-Curve (AUC) for an FDH frontier.

    Parameters:
        df (pd.DataFrame): DataFrame with a 'frontier' column.
        x_header (str): The column name for the x-variable.
        y_header (str): The column name for the y-variable.

    Returns:
        tuple: (total_auc, auc_percentage)
    """
    df_est = df[df["frontier"] == 0].copy()
    df_sorted = df_est.sort_values(by=x_header).reset_index(drop=True)
    total_auc = 0.0

    for i in range(len(df_sorted) - 1):
        a = df_sorted.loc[i, y_header]
        b = df_sorted.loc[i + 1, y_header]
        h = df_sorted.loc[i + 1, x_header] - df_sorted.loc[i, x_header]
        total_auc += (a + b) * h / 2.0
        if i == 0:
            total_auc += a * df_sorted.loc[i, x_header]

    max_x = df_sorted[x_header].max()
    max_y = df_sorted[y_header].max()
    auc_percentage = (total_auc / (max_x * max_y)) * 100
    return total_auc, auc_percentage


def hvi_normalization(df, x_headers, y_headers):
    """
    Calculate the Hypervolume Indicator (HVI) for the frontier DMUs.

    Parameters:
        df (pd.DataFrame): DataFrame with a 'frontier' column.
        x_headers (list): List of x-dimension column names.
        y_headers (list): List of y-dimension column names.

    Returns:
        tuple: (HV_percentage, normalized_HV)
    """
    df_plot = df[df["frontier"] == 0].copy()
    hv_points = df_plot[x_headers + y_headers].to_numpy()
    ref_point = np.amax(hv_points, axis=0)
    ind = HV(ref_point=ref_point)
    original_HV = ind(hv_points)
    HV_percentage = 1 - original_HV / np.prod(ref_point)
    normalized_HV = math.factorial(len(y_headers) + 1) * HV_percentage
    return HV_percentage, normalized_HV


def hull_comparison(n_deaPoints, auc_percentage_fdh, dea_total_auc, total_auc_fdh):
    """
    Compute the Hull Analysis Comparison (HAC) metric.

    For this example the HAC is defined as the difference between the total AUC computed via DEA and FDH.
    (In practice, replace with your own HAC calculation if needed.)

    Parameters:
        n_deaPoints: (Not used in this placeholder implementation.)
        auc_percentage_fdh (float): AUC percentage by the FDH method.
        dea_total_auc (float): Total AUC calculated by the DEA method.
        total_auc_fdh (float): Total AUC calculated by the FDH method.

    Returns:
        float: The HAC value.
    """
    return dea_total_auc - total_auc_fdh


def calc_hvi_area(df, x_headers, y_headers):
    """
    Calculate several efficiency metrics on the frontier DMUs:
        - HVI (normalized and as a percentage)
        - MRTS statistics (mean, mean without extremes, median)
        - FDH-based AUC

    Also computes a HAC metric (here as a placeholder).

    Parameters:
        df (pd.DataFrame): DataFrame with a 'frontier' column.
        x_headers (list): List of x-dimension column names (e.g., ['y1']).
        y_headers (list): List of y-dimension column names (e.g., ['y2']).

    Returns:
        dict: Dictionary with keys:
            'normalized_HV', 'HV_percentage', 'MRTS_mean', 'MRTS_mean_without_extremes',
            'MRTS_median', 'AUC', 'AUC_percentage', and 'HAC'.
    """
    hv_pct, norm_HV = hvi_normalization(df, x_headers, y_headers)
    m_mean, m_mean_no_ext, m_median = calc_mrts(df, x_header=x_headers[0], y_header=y_headers[0])
    total_auc, auc_pct = calc_fdh_auc(df, x_header=x_headers[0], y_header=y_headers[0])

    # In this placeholder, we use the FDH values for the DEA ones.
    dea_total_auc, dea_auc_pct = total_auc, auc_pct
    hac = hull_comparison(None, auc_pct, dea_total_auc, total_auc)

    return {
        "normalized_HV": norm_HV,
        "HV_percentage": hv_pct,
        "MRTS_mean": m_mean,
        "MRTS_mean_without_extremes": m_mean_no_ext,
        "MRTS_median": m_median,
        "AUC": total_auc,
        "AUC_percentage": auc_pct,
        "HAC": hac,
    }


# =====================
# REGRESSION ANALYSIS
# =====================

def calc_reg(df):
    """
    Perform OLS regression on frontier DMUs.
    Uses the production function input (here, 'real_x') and outputs (y1, y2, y3).

    Parameters:
        df (pd.DataFrame): DataFrame containing at least the columns:
                           'real_x', 'y1', 'y2', 'y3', and 'frontier'.

    Returns:
        RegressionResults: A statsmodels OLS regression results object.
    """
    df_reg = df[df["frontier"] == 0].copy()
    df_reg["minus_x"] = -df_reg["real_x"]
    # Regression formula with interaction terms between outputs.
    formula = "minus_x ~ y1 + y2 + y3 + y1:y2 + y1:y3 + y2:y3"
    model = sm.ols(formula, data=df_reg).fit()
    return model


# =====================
# EXAMPLE MAIN (for testing)
# =====================

if __name__ == "__main__":
    # Example: set scenario parameters
    x_pow, y_pow = 0.5, 2
    # Simulate data (100 DMUs per cost level)
    df = gen_final_data_df(n_points=100, wide=[40, 60], x_pow=x_pow, y_pow=y_pow, plotting=False)

    # Label frontier DMUs (using a simple max-on-y rule)
    df = label_frontier(df, x_headers=["y1"], y_headers=["y2"])

    # Calculate MRTS, AUC, HVI, and HAC (using y1 for x and y2 for y)
    m_mean, m_mean_no_ext, m_median = calc_mrts(df, x_header="y1", y_header="y2")
    auc_total, auc_pct = calc_fdh_auc(df, x_header="y1", y_header="y2")
    hv_pct, norm_HV = hvi_normalization(df, x_headers=["y1"], y_headers=["y2"])
    hvi_results = calc_hvi_area(df, x_headers=["y1"], y_headers=["y2"])

    # Run regression on frontier DMUs
    reg_model = calc_reg(df)

    print("MRTS (mean, mean without extremes, median):", m_mean, m_mean_no_ext, m_median)
    print("AUC total, AUC %:", auc_total, auc_pct)
    print("HVI (HV%, normalized HV):", hv_pct, norm_HV)
    print("HVI results:", hvi_results)
    print(reg_model.summary())